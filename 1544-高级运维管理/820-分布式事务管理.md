---
show: step
version: 1.0
enable_checker: true
---

# 分布式事务管理

## 课程介绍

本课程主要介绍巨杉数据库的事务功能，通过实验来检验数据库的事务处理能力。

**请点击右侧选择使用的实验环境**

**部署架构**

本课程中的SequoiaDB巨杉数据库的集群拓扑结构为三分区单副本。

**实验环境**

课程使用的实验环境为Ubuntu Linux 16.04 64位版本。

## 初始化环境

1）使用sdbadmin用户实行如下shell脚本init.sh

```
#!/bin/bash
mysql -uroot -h127.0.0.1 -e "drop database if exists company;create database  if not exists company;"
mysql -uroot -h127.0.0.1 -e "drop table if exists company.order_info;create table if not exists company.order_info(order_id int AUTO_INCREMENT PRIMARY KEY,product_name varchar(20),price float(5,2));"
mysql -uroot -h127.0.0.1 -e "insert into company.order_info(product_name,price)values('pic',128.21)"
```

2）检验巨杉数据库事务是否开启

登录SDB控制下执行如下命令

```
db.snapshot(13,{},{NodeName:null,transactionon:null})
```

如果transactionon参数返回为true表示事务功能已经开启。事务功能默认为开启状态。

## 事务的原子性

1）登录MySQL实例

```
mysql -uroot -h127.0.0.1 -Dcompany
```

2）查看数据

```
select * from order_info;
```

3）开启事务操作

原子性保证在同一个事务内所有操作一起成功或者一起失败。

```
begin;
insert into order_info(product_name,price)values('water',1.23);
update order_info set price=1.00 where order_id=1;
select * from order_info;
rollback;
```

4）再次查看数据。

```
select * from order_info;
```

上一步的rollback把同一事务内的所有操作进行了回滚。

## 事务的持久性

1）查看数据

```
select * from order_info;
```

2）开启事务操作

开启事务后插入一条数据，并提交。

```
begin;
insert into order_info(product_name,price)values('water',1.23);
commit;
```

3）再次查看数据

```
select * from order_info;
```

由于事务已经被提交，被插入的数据被保存在数据库中。

## 事务的隔离

### 设置隔离级别--RU 读未提交

1）修改隔离级别

登录SDB控制台，连接数据库后，修改隔离界别。

```
sdb=new Sdb()
db.updateConf({transisolation:0},{Global:true})
```

transisolation参数指定隔离界别，0表示隔离界别为读未提交。

Global为true表示对所有节点生效。

关于更多参数说明，请参考如下链接：

[http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1432190643-edition_id-0](http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1432190643-edition_id-0)

2）修改数据
开启第一个终端，登录MySQL，这个终端表示sessionA。

使用sessionA开启事务后修改数据。

```
begin;
updae company.order_info set price=2.00 where order_id=1;
```

3）查询结果
开启第二个终端，登录MySQL，表示sessionB。

使用sessionB开启事务后查询。

```
select * from company.order_info;
```

可以看到，即使sessionA未进行提交，SessionB依然可以看到修改过的数据。

### RC读已提交

1）修改隔离级别

登录SDB控制台，连接数据库后，修改隔离界别。

```
sdb=new Sdb()
db.updateConf({transisolation:1},{Global:true})
```

transisolation参数指定隔离界别，1表示隔离界别为读已提交。

2）修改数据
开启第一个终端，登录MySQL，这个终端表示sessionA。

sessionA

```
begin;
update company.order_info set price=4.00 where order_id=1;
```

开启第二个终端，登录MySQL，表示sessionB。

sessionB

```
begin;
select * from company.order_info;
```

此时sessionB无法看到修改后的数据。

3）提交后查询结果
sessionA执行提交操作

```
commit;
```

sessionB执行查询

```
select * from company.order_info
```

只有当数sessionA据提交后，sessionB才能看到修改后的数据。

### RS读稳定性

1）修改隔离级别

登录SDB控制台，连接数据库后，修改隔离界别。

```
sdb=new Sdb()
db.updateConf({transisolation:2},{Global:true})
```

transisolation参数指定隔离界别，2表示隔离界别为读已提交。

2）查询数据
开启第一个终端，登录MySQL，这个终端表示sessionA。

使用sessionA开启事务后查询数据。

```
begin
select * from company.order_info;
```

3）修改数据
开启第二个终端，登录MySQL，表示sessionB。

```
begin;
update company.order_info set price=5.00 where order_id=1;
```

sessionB的update操作发生等待，只有等sessionA执行rollback或者commit后，
sessionB才能执行成功。
