---
show: step
version: 2.0
enable_checker: true
---

# 分布式事务管理

## 课程介绍

本课程主要介绍巨杉数据库的事务功能，通过实验来检验数据库的事务处理能力。

#### 请点击右侧选择使用的实验环境

#### 部署架构：

本课程中 SequoiaDB 巨杉数据库的集群拓扑结构为三分区单副本，其中包括：1 个 SequoiaSQL-MySQL 数据库实例节点、1 个引擎协调节点，1 个编目节点与 3 个数据节点。

![820-1](https://doc.shiyanlou.com/courses/1469/1207281/8d88e6faed223a26fcdc66fa2ef8d3c5)

如若详细了解 SequoiaDB 巨杉数据库系统架构，请参考如下链接：

* [SequoiaDB 系统架构](http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1519649201-edition_id-0)

#### 实验环境
课程使用的实验环境为 Ubuntu Linux 16.04 64 位版本。SequoiaDB 数据库引擎以及 SequoiaSQL-MySQL 实例均为 3.4 版本。

## 切换用户及查看数据库版本

#### 切换到 sdbadmin 用户

部署 SequoiaDB 巨杉数据库和 SequoiaSQL-MySQL 实例的操作系统用户为 sdbadmin。

```shell
su - sdbadmin ;
```

>Note:
>
>用户 sdbadmin 的密码为 `sdbadmin`。

#### 查看巨杉数据库版本

查看 SequoiaDB 巨杉数据库引擎版本。

```shell
sequoiadb --version ;
```

操作截图：

![820-2](https://doc.shiyanlou.com/courses/1469/1207281/b4082b0d6d6bdf89d229aa713a53759d)

## 查看节点启动列表

查看 SequoiaDB 巨杉数据库引擎节点列表。

```shell
sdblist ;
```

操作截图：

![820-3](https://doc.shiyanlou.com/courses/1469/1207281/02fcaa58ac27e91688ead137fa748d6e)

>Note:
>
>如果显示的节点数量与预期不符，请稍等初始化完成并重试该步骤。

## 创建数据库及数据表

进入 MySQL shell ，连接 SequoiaSQL-MySQL 实例并创建 company 数据库实例，为接下来验证 MySQL 语法特性做准备。

#### 登录 MySQL shell 

```shell
/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root ;
```

#### 创建数据库实例

```sql
create database company ;
use company ;
```

#### 创建数据表
在 SequoiaSQL-MySQL 实例中创建的表将会默认使用 SequoiaDB 数据库存储引擎，包含主键或唯一键的表将会默认以唯一键作为分区键，进行自动分区。

1）创建包含自增主键字段的 employee 表；

```sql
create table employee (
    empno int auto_increment primary key, 
    ename varchar(128), 
    age int
) ;
```

2）写入数据；

```sql
insert into employee (ename, age) values ("Jacky", 36) ;
```

3）查看数据

```sql
select * from employee ;
```

4）退出 MySQL shell；

```sql
quit ;
```

## 检查是否开启事务

检验 SequoiaDB 巨杉数据库节点事务是否开启。

1）在 Linux 命令行中进入 SequoiaDB shell 交互式界面；

```shell
sdb ;
```

2）使用 JavaScript 连接协调节点，并获取数据库连接；

```javascript
var db = new Sdb ("localhost",11810) ;
```

3）查询节点配置快照；

```javascript
db.snapshot(SDB_SNAP_CONFIGS, {}, { NodeName : "" , transactionon : "" } ) ;
```

如果 transactionon 参数返回为 true 表示事务功能已经开启。事务功能默认为开启状态。

4）退出 SequoiaDB shell；

```shell
quit ;
```

## 事务的原子性

1）登录 MySQL shell；

```shell
/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root ;
```

2）切换数据库；

```sql
use company ;
```

2）查看数据；

```sql
select * from employee ;
```

3）开启事务操作；

原子性保证在同一个事务内所有操作一起成功或者一起失败。

开始事务；

```sql
begin ;
```

写入数据；

```sql
insert into employee (ename, age) values ("Alice", 18) ;
```

更新数据；

```sql
update employee set age = 37 where ename = "Jacky" ;
```

查看数据情况；

```sql
select * from employee ;
```

提交事务；

```sql
rollback ;
```

再次查看数据

```sql
select * from employee ;
```

上一步的 rollback 把同一事务内的所有操作进行了回滚。

## 事务的持久性
1）开始事务；

```sql
begin ;
```

2）写入数据；

```sql
insert into employee (ename, age) values ("Susan", 21) ;
```

3）提交事务；

```sql
commit ;
```

4）查询写入数据，确保之前写入的数据被正确提交；

```sql
select * from employee where ename = "Susan" ;
```

由于事务已经被提交，被插入的数据被保存在数据库中。

## 事务的隔离

#### 设置隔离级别--RU 读未提交

1）修改隔离级别

登录 SequoiaDB shell 控制台，连接数据库后，修改隔离界别。

在 Linux 命令行中进入 SequoiaDB shell 交互式界面；

```shell
sdb ;
```

使用 JavaScript 连接协调节点，并获取数据库连接；

```javascript
var db = new Sdb ("localhost",11810) ;
```

修改事务隔离级别，0 代表读未提交；

```javascript
db.updateConf ( { transisolation : 0 } , { Global : true } ) ;
```

> Note:
> - transisolation 参数指定隔离界别，0 表示隔离界别为读未提交。
> - Global 为 true 表示对所有节点生效。
> - 关于更多参数说明，请参考如下链接：
[http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1432190643-edition_id-0](http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1432190643-edition_id-0) 。

查询节点事务隔离级别；

```javascript
db.snapshot(SDB_SNAP_CONFIGS, {}, { NodeName : "" , transactionon : "", transisolation: "" } ) ;
```

退出 SequoiaDB shell；

```shell
quit ;
```

2）修改数据
开启第一个终端，登录 MySQL，这个终端表示 sessionA，开启事务后修改数据。

登录 MySQL shell；

```shell
/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root ;
```

开启事务；

```sql
begin ;
```

更新数据；

```sql
update company.employee set age = 22 where ename = "Susan" ;
```

3）查询结果
开启第二个终端，登录 MySQL，表示 sessionB；

登录 MySQL shell；

```shell
/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root ;
```

使用 sessionB 开启事务后查询；

```sql
select * from company.employee ;
```

可以看到，即使 sessionA 未进行提交，SessionB 依然可以看到修改过的数据。

#### RC读已提交

1）修改隔离级别

登录 SequoiaDB shell 控制台，连接数据库后，修改隔离界别。

在 Linux 命令行中进入 SequoiaDB shell 交互式界面；

```shell
sdb ;
```

使用 JavaScript 连接协调节点，并获取数据库连接；

```javascript
var db = new Sdb ("localhost",11810) ;
```

修改事务隔离级别，1 代表读未提交；

```javascript
db.updateConf ( { transisolation : 1 } , { Global : true } ) ;
```

查询节点事务隔离级别；

```javascript
db.snapshot(SDB_SNAP_CONFIGS, {}, { NodeName : "" , transactionon : "", transisolation: "" } ) ;
```

2）修改数据
开启第一个终端，登录 MySQL，这个终端表示 sessionA。

sessionA

```sql
begin ;
update company.employee set age = 32 where ename = "Susan" ;
```

开启第二个终端，登录 MySQL，表示 sessionB。

sessionB

```sql
begin ;
select * from company.employee ;
```

此时 sessionB 无法看到修改后的数据。

3）提交后查询结果
sessionA 执行提交操作

```sql
commit ;
```

sessionB执行查询

```sql
select * from company.employee ;
```

只有当数 sessionA 据提交后，sessionB 才能看到修改后的数据。

### RS读稳定性

1）修改隔离级别

登录 SequoiaDB shell 控制台，连接数据库后，修改隔离界别。

在 Linux 命令行中进入 SequoiaDB shell 交互式界面；

```shell
sdb ;
```

使用 JavaScript 连接协调节点，并获取数据库连接；

```javascript
var db = new Sdb ("localhost",11810) ;
```

修改事务隔离级别，2 表示隔离界别为读已提交；

```javascript
db.updateConf({transisolation:2},{Global:true}) ;
```

查询节点事务隔离级别；

```javascript
db.snapshot(SDB_SNAP_CONFIGS, {}, { NodeName : "" , transactionon : "", transisolation: "" } ) ;
```

2）查询数据
开启第一个终端，登录 MySQL，这个终端表示 sessionA。

使用 sessionA 开启事务后查询数据。

```sql
begin ; 
select * from company.employee ;
```

3）修改数据
开启第二个终端，登录 MySQL，表示 sessionB。

```sql
begin ;
update company.employee set age = 42 where ename = "Susan" ;
```

sessionB 的 update 操作发生等待，只有等 sessionA 执行 rollback 或者 commit 后，sessionB 才能执行成功。
